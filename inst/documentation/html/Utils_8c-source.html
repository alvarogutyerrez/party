<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>party: Utils.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>Utils.c</h1><a href="Utils_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00009 <span class="preprocessor">#include "<a class="code" href="party_8h.html">party.h</a>"</span>
00010                 
00011                 
<a name="l00023"></a><a class="code" href="Utils_8h.html#a0">00023</a> <span class="keywordtype">void</span> <a class="code" href="Utils_8c.html#a0">C_kronecker</a> (<span class="keyword">const</span> <span class="keywordtype">double</span> *A, <span class="keyword">const</span> <span class="keywordtype">int</span> m, <span class="keyword">const</span> <span class="keywordtype">int</span> n,
00024                   <span class="keyword">const</span> <span class="keywordtype">double</span> *B, <span class="keyword">const</span> <span class="keywordtype">int</span> r, <span class="keyword">const</span> <span class="keywordtype">int</span> s,
00025                   <span class="keywordtype">double</span> *ans) {
00026 
00027     <span class="keywordtype">int</span> i, j, k, l, mr, js, ir;
00028     <span class="keywordtype">double</span> y;
00029 
00030     mr = m * r;
00031     <span class="keywordflow">for</span> (i = 0; i &lt; m; i++) {
00032         ir = i * r;
00033         <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
00034             js = j * s;
00035             y = A[j*m + i];
00036             <span class="keywordflow">for</span> (k = 0; k &lt; r; k++) {
00037                 <span class="keywordflow">for</span> (l = 0; l &lt; s; l++) {
00038                     ans[(js + l) * mr + ir + k] = y * B[l * r + k];
00039                 }
00040             }
00041         }
00042     }
00043 }  
00044 
00045 
<a name="l00052"></a><a class="code" href="Utils_8c.html#a1">00052</a> SEXP <a class="code" href="Utils_8c.html#a1">R_kronecker</a> (SEXP A, SEXP B) {
00053 
00054     <span class="comment">/*  The Kronecker product, a real (mr x ns) matrix */</span>
00055     SEXP ans; 
00056     <span class="keywordtype">int</span> *adim, *bdim;
00057 
00058     <span class="keywordflow">if</span> (!isReal(A) || !isReal(B)) 
00059         error(<span class="stringliteral">"R_kronecker: A and B are not of type REALSXP"</span>);
00060 
00061     <span class="keywordflow">if</span> (isMatrix(A)) {
00062         adim = INTEGER(getAttrib(A, R_DimSymbol));
00063     } <span class="keywordflow">else</span> {
00064         <span class="comment">/* assume row vectors */</span>
00065         adim = Calloc(2, <span class="keywordtype">int</span>);
00066         adim[0] = 1;
00067         adim[1] = LENGTH(A);
00068     }
00069     
00070     <span class="keywordflow">if</span> (isMatrix(B)) {
00071         bdim = INTEGER(getAttrib(B, R_DimSymbol));
00072     } <span class="keywordflow">else</span> {
00073         <span class="comment">/* assume row vectors */</span>
00074         bdim = Calloc(2, <span class="keywordtype">int</span>);
00075         bdim[0] = 1;
00076         bdim[1] = LENGTH(B);
00077     }
00078 
00079     PROTECT(ans = allocMatrix(REALSXP, 
00080                               adim[0] * bdim[0], 
00081                               adim[1] * bdim[1]));
00082     <a class="code" href="Utils_8c.html#a0">C_kronecker</a>(REAL(A), adim[0], adim[1], 
00083                 REAL(B), bdim[0], bdim[1], REAL(ans));
00084     <span class="keywordflow">if</span> (!isMatrix(A)) Free(adim); 
00085     <span class="keywordflow">if</span> (!isMatrix(B)) Free(bdim);
00086     UNPROTECT(1);
00087     <span class="keywordflow">return</span>(ans);
00088 }
00089 
00090 
<a name="l00097"></a><a class="code" href="Utils_8c.html#a2">00097</a> SEXP <a class="code" href="Utils_8c.html#a2">CR_svd</a> (SEXP x, SEXP svdmem) {
00098 
00099     <span class="keywordtype">int</span> p, i;
00100     <span class="keywordtype">double</span> *du, *dv;
00101 
00102     <span class="keywordflow">if</span> (!isMatrix(x) || !isReal(x))
00103         error(<span class="stringliteral">"x is not a real matrix"</span>);
00104 
00105     du = REAL(GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a14">PL2_uSym</a>));
00106     dv = REAL(GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a15">PL2_vSym</a>));
00107     p = INTEGER(GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a17">PL2_pSym</a>))[0];
00108     <span class="keywordflow">for</span> (i = 0; i &lt; p*p; i++) {
00109         du[i] = 0.0;
00110         dv[i] = 0.0;
00111     }
00112     SET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a9">PL2_svdSym</a>, <a class="code" href="Utils_8h.html#a1">La_svd</a>(GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a12">PL2_jobuSym</a>), 
00113         GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a13">PL2_jobvSym</a>), x, GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a16">PL2_sSym</a>), 
00114         GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a14">PL2_uSym</a>), GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a15">PL2_vSym</a>), 
00115         GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a11">PL2_methodSym</a>)));
00116     <span class="keywordflow">return</span>(R_NilValue);
00117 }
00118 
00119 
<a name="l00128"></a><a class="code" href="Utils_8h.html#a3">00128</a> <span class="keywordtype">void</span> <a class="code" href="Utils_8c.html#a3">C_MPinv</a> (SEXP x, <span class="keywordtype">double</span> tol, SEXP svdmem, SEXP ans) {
00129 
00130     SEXP svdx, d, u, vt, dummy;
00131     <span class="keywordtype">int</span> i, j, p, k, *positive;
00132     <span class="keywordtype">double</span> *dd, *du, *dvt, *dMPinv;
00133     <span class="keywordtype">double</span> *drank;
00134     
00135     drank = REAL(GET_SLOT(ans, <a class="code" href="Classes_8c.html#a8">PL2_rankSym</a>));
00136     dMPinv = REAL(GET_SLOT(ans, <a class="code" href="Classes_8c.html#a7">PL2_MPinvSym</a>));
00137 
00138     dummy = <a class="code" href="Utils_8c.html#a2">CR_svd</a>(x, svdmem);
00139     svdx = GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a9">PL2_svdSym</a>);
00140     d = VECTOR_ELT(svdx, 0);
00141     dd = REAL(d);
00142     u = VECTOR_ELT(svdx, 1);
00143     du = REAL(u);
00144     vt = VECTOR_ELT(svdx, 2);
00145     dvt = REAL(vt);
00146     p = LENGTH(d);
00147 
00148     <span class="keywordflow">if</span> (tol * dd[0] &gt; tol) tol = tol * dd[0];
00149 
00150     positive = Calloc(p, <span class="keywordtype">int</span>); 
00151     
00152     drank[0] = 0.0;
00153     <span class="keywordflow">for</span> (i = 0; i &lt; p; i++) {
00154         <span class="keywordflow">if</span> (dd[i] &gt; tol) {
00155             positive[i] = 1;
00156             drank[0] += 1.0;
00157         } 
00158     }
00159     
00160     <span class="keywordflow">for</span> (j = 0; j &lt; p; j++) {
00161         <span class="keywordflow">if</span> (positive[j]) {
00162             <span class="keywordflow">for</span> (i = 0; i &lt; p; i++)
00163                 du[j * p + i] *= (1 / dd[j]);
00164         }
00165     }
00166     
00167     <span class="keywordflow">for</span> (i = 0; i &lt; p; i++) {
00168         <span class="keywordflow">for</span> (j = 0; j &lt; p; j++) {
00169             dMPinv[j * p + i] = 0.0;
00170             <span class="keywordflow">for</span> (k = 0; k &lt; p; k++) {
00171                 <span class="keywordflow">if</span> (positive[k])
00172                     dMPinv[j * p + i] += dvt[i * p + k] * du[p * k + j]; 
00173             }
00174         }
00175     }
00176 
00177     Free(positive);
00178 }
00179 
<a name="l00187"></a><a class="code" href="Utils_8c.html#a4">00187</a> SEXP <a class="code" href="Utils_8c.html#a4">R_MPinv</a> (SEXP x, SEXP tol, SEXP svdmem) {
00188 
00189     SEXP ans;
00190     <span class="keywordtype">int</span> p;
00191 
00192     <span class="keywordflow">if</span> (!isMatrix(x) || !isReal(x))
00193         error(<span class="stringliteral">"R_MPinv: x is not a real matrix"</span>);
00194 
00195     <span class="keywordflow">if</span> (<a class="code" href="Utils_8c.html#a18">nrow</a>(x) != <a class="code" href="Utils_8c.html#a19">ncol</a>(x)) 
00196         error(<span class="stringliteral">"R_MPinv: x is not a square matrix"</span>);
00197 
00198     <span class="keywordflow">if</span> (!isReal(tol) || LENGTH(tol) != 1)
00199         error(<span class="stringliteral">"R_MPinv: tol is not a scalar real"</span>);
00200     
00201     p = <a class="code" href="Utils_8c.html#a18">nrow</a>(x);
00202     <span class="keywordflow">if</span> (p != INTEGER(GET_SLOT(svdmem, <a class="code" href="Classes_8c.html#a17">PL2_pSym</a>))[0])
00203         error(<span class="stringliteral">"R_MPinv: dimensions don't match"</span>);
00204 
00205     PROTECT(ans = NEW_OBJECT(MAKE_CLASS(<span class="stringliteral">"LinStatExpectCovarMPinv"</span>)));
00206     SET_SLOT(ans, <a class="code" href="Classes_8c.html#a7">PL2_MPinvSym</a>, PROTECT(allocMatrix(REALSXP, p, p)));
00207     SET_SLOT(ans, <a class="code" href="Classes_8c.html#a8">PL2_rankSym</a>, PROTECT(allocVector(REALSXP, 1)));
00208     
00209     <a class="code" href="Utils_8c.html#a3">C_MPinv</a>(x, REAL(tol)[0], svdmem, ans);
00210     
00211     UNPROTECT(3);
00212     <span class="keywordflow">return</span>(ans);
00213 }
00214 
<a name="l00222"></a><a class="code" href="Utils_8h.html#a4">00222</a> <span class="keywordtype">double</span> <a class="code" href="Utils_8c.html#a5">C_max</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keyword">const</span> <span class="keywordtype">int</span> n) {
00223    <span class="keywordtype">double</span> tmp = 0.0;
00224    <span class="keywordtype">int</span> i;
00225    
00226    <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
00227        <span class="keywordflow">if</span> (x[i] &gt; tmp) tmp = x[i];
00228    }
00229    <span class="keywordflow">return</span>(tmp);
00230 }
00231 
00232 
<a name="l00238"></a><a class="code" href="Utils_8c.html#a6">00238</a> SEXP <a class="code" href="Utils_8c.html#a6">R_max</a>(SEXP x) {
00239 
00240     SEXP ans;
00241     <span class="keywordtype">int</span> n;
00242     
00243     <span class="keywordflow">if</span> (!isReal(x)) 
00244         error(<span class="stringliteral">"R_max: x is not of type REALSXP"</span>);
00245     n = LENGTH(x);
00246     PROTECT(ans = allocVector(REALSXP, 1));
00247     REAL(ans)[0] = <a class="code" href="Utils_8c.html#a5">C_max</a>(REAL(x), n);
00248     UNPROTECT(1);
00249     <span class="keywordflow">return</span>(ans);
00250 }
00251 
00252 
<a name="l00259"></a><a class="code" href="Utils_8h.html#a5">00259</a> <span class="keywordtype">void</span> <a class="code" href="Utils_8c.html#a7">C_abs</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> n) {
00260 
00261     <span class="keywordtype">int</span> i;
00262     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) x[i] = fabs(x[i]);
00263 }
00264 
00265 
<a name="l00271"></a><a class="code" href="Utils_8c.html#a8">00271</a> SEXP <a class="code" href="Utils_8c.html#a8">R_abs</a>(SEXP x) {
00272 
00273     SEXP ans;
00274     <span class="keywordtype">int</span> n;
00275     
00276     <span class="keywordflow">if</span> (!isReal(x)) 
00277         error(<span class="stringliteral">"R_max: x is not of type REALSXP"</span>);
00278     n = LENGTH(x);
00279     PROTECT(ans = duplicate(x));
00280     <a class="code" href="Utils_8c.html#a7">C_abs</a>(REAL(ans), n);
00281     UNPROTECT(1);
00282     <span class="keywordflow">return</span>(ans);
00283 }
00284 
00285 
<a name="l00297"></a><a class="code" href="Utils_8h.html#a6">00297</a> <span class="keywordtype">void</span> <a class="code" href="Utils_8c.html#a9">C_matprod</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> nrx, <span class="keywordtype">int</span> ncx,
00298                <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> nry, <span class="keywordtype">int</span> ncy, <span class="keywordtype">double</span> *z)
00299 {
00300     <span class="keywordtype">char</span> *transa = <span class="stringliteral">"N"</span>, *transb = <span class="stringliteral">"N"</span>;
00301     <span class="keywordtype">double</span> one = 1.0, zero = 0.0;
00302     <span class="keywordtype">int</span> i;
00303 
00304     <span class="keywordflow">if</span> (nrx &gt; 0 &amp;&amp; ncx &gt; 0 &amp;&amp; nry &gt; 0 &amp;&amp; ncy &gt; 0) {
00305         F77_CALL(dgemm)(transa, transb, &amp;nrx, &amp;ncy, &amp;ncx, &amp;one,
00306                         x, &amp;nrx, y, &amp;nry, &amp;zero, z, &amp;nrx);
00307     } <span class="keywordflow">else</span> <span class="comment">/* zero-extent operations should return zeroes */</span>
00308         <span class="keywordflow">for</span>(i = 0; i &lt; nrx*ncy; i++) z[i] = 0;
00309 }
00310 
00311 
<a name="l00318"></a><a class="code" href="Utils_8c.html#a10">00318</a> SEXP <a class="code" href="Utils_8c.html#a10">R_matprod</a>(SEXP x, SEXP y) {
00319 
00320     SEXP ans;
00321     
00322     <span class="keywordtype">int</span> nrx, ncx, nry, ncy;
00323     
00324     nrx = <a class="code" href="Utils_8c.html#a18">nrow</a>(x);
00325     ncx = <a class="code" href="Utils_8c.html#a19">ncol</a>(x);
00326     nry = <a class="code" href="Utils_8c.html#a18">nrow</a>(y);
00327     ncy = <a class="code" href="Utils_8c.html#a19">ncol</a>(y);
00328 
00329     <span class="keywordflow">if</span> (ncx != nry)
00330         error(<span class="stringliteral">"R_matprod: dimensions don't match"</span>);
00331     PROTECT(ans = allocMatrix(REALSXP, nrx, ncy));
00332     <a class="code" href="Utils_8c.html#a9">C_matprod</a>(REAL(x), nrx, ncx, REAL(y), nry, ncy, REAL(ans));
00333     UNPROTECT(1);
00334     <span class="keywordflow">return</span>(ans);
00335 }
00336 
00337 
<a name="l00349"></a><a class="code" href="Utils_8h.html#a7">00349</a> <span class="keywordtype">void</span> <a class="code" href="Utils_8c.html#a11">C_matprodT</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> nrx, <span class="keywordtype">int</span> ncx,
00350                 <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> nry, <span class="keywordtype">int</span> ncy, <span class="keywordtype">double</span> *z)
00351 {
00352     <span class="keywordtype">char</span> *transa = <span class="stringliteral">"N"</span>, *transb = <span class="stringliteral">"T"</span>;
00353     <span class="keywordtype">double</span> one = 1.0, zero = 0.0;
00354     <span class="keywordtype">int</span> i;
00355 
00356     <span class="keywordflow">if</span> (nrx &gt; 0 &amp;&amp; ncx &gt; 0 &amp;&amp; nry &gt; 0 &amp;&amp; ncy &gt; 0) {
00357         F77_CALL(dgemm)(transa, transb, &amp;nrx, &amp;nry, &amp;ncy, &amp;one,
00358                         x, &amp;nrx, y, &amp;nry, &amp;zero, z, &amp;nrx);
00359     } <span class="keywordflow">else</span> <span class="comment">/* zero-extent operations should return zeroes */</span>
00360         <span class="keywordflow">for</span>(i = 0; i &lt; nrx*nry; i++) z[i] = 0;
00361 }
00362 
00363 
<a name="l00370"></a><a class="code" href="Utils_8c.html#a12">00370</a> SEXP <a class="code" href="Utils_8c.html#a12">R_matprodT</a>(SEXP x, SEXP y) {
00371 
00372     SEXP ans;
00373     <span class="keywordtype">int</span> nrx, ncx, nry, ncy;
00374     
00375     nrx = <a class="code" href="Utils_8c.html#a18">nrow</a>(x);
00376     ncx = <a class="code" href="Utils_8c.html#a19">ncol</a>(x);
00377     nry = <a class="code" href="Utils_8c.html#a18">nrow</a>(y);
00378     ncy = <a class="code" href="Utils_8c.html#a19">ncol</a>(y);
00379 
00380     <span class="keywordflow">if</span> (ncx != ncy)
00381         error(<span class="stringliteral">"R_matprod: dimensions don't match"</span>);
00382     PROTECT(ans = allocMatrix(REALSXP, nrx, nry));
00383     <a class="code" href="Utils_8c.html#a11">C_matprodT</a>(REAL(x), nrx, ncx, REAL(y), nry, ncy, REAL(ans));
00384     UNPROTECT(1);
00385     <span class="keywordflow">return</span>(ans);
00386 }
00387 
00388 
<a name="l00397"></a><a class="code" href="Utils_8h.html#a2">00397</a> <span class="keywordtype">void</span> <a class="code" href="Utils_8c.html#a13">C_SampleNoReplace</a>(<span class="keywordtype">int</span> *x, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> *ans) {
00398      
00399     <span class="keywordtype">int</span> i, j, n = m;
00400 
00401     <span class="keywordflow">for</span> (i = 0; i &lt; m; i++)
00402         x[i] = i;
00403     <span class="keywordflow">for</span> (i = 0; i &lt; k; i++) {
00404         j = n * unif_rand(); 
00405         ans[i] = x[j];
00406         x[j] = x[--n];  
00407     }
00408 }
00409 
00410 
<a name="l00416"></a><a class="code" href="Utils_8c.html#a14">00416</a> SEXP <a class="code" href="Utils_8c.html#a14">R_permute</a>(SEXP m) {
00417     
00418     SEXP x, ans;
00419     <span class="keywordtype">int</span> n;
00420     
00421     n = INTEGER(m)[0];
00422     PROTECT(x = allocVector(INTSXP, n));
00423     PROTECT(ans = allocVector(INTSXP, n));
00424     <a class="code" href="Utils_8c.html#a13">C_SampleNoReplace</a>(INTEGER(x), n, n, INTEGER(ans));
00425     UNPROTECT(2);
00426     <span class="keywordflow">return</span>(ans);
00427 }
00428 
00429 
<a name="l00436"></a><a class="code" href="Utils_8c.html#a15">00436</a> SEXP <a class="code" href="Utils_8c.html#a15">R_rsubset</a>(SEXP m, SEXP k) {
00437     
00438     SEXP x, ans;
00439     <span class="keywordtype">int</span> n, j;
00440     
00441     n = INTEGER(m)[0];
00442     j = INTEGER(k)[0];
00443     PROTECT(x = allocVector(INTSXP, n));
00444     PROTECT(ans = allocVector(INTSXP, j));
00445     <a class="code" href="Utils_8c.html#a13">C_SampleNoReplace</a>(INTEGER(x), n, j, INTEGER(ans));
00446     UNPROTECT(2);
00447     <span class="keywordflow">return</span>(ans);
00448 }
00449 
00450 
<a name="l00458"></a><a class="code" href="Utils_8h.html#a11">00458</a> <span class="keywordtype">int</span> <a class="code" href="Utils_8c.html#a16">i_in_set</a>(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> *iset, <span class="keywordtype">int</span> p) {
00459 
00460     <span class="keywordtype">int</span> j, is = 0;
00461         
00462     <span class="keywordflow">if</span> (p == 0) <span class="keywordflow">return</span>(0);
00463                     
00464     <span class="keywordflow">for</span> (j = 0; j &lt; p; j++) {
00465         <span class="keywordflow">if</span> (iset[j] == i) {  
00466             is = 1;
00467             <span class="keywordflow">break</span>; 
00468         }
00469     }
00470     <span class="keywordflow">return</span>(is);
00471 }
00472 
<a name="l00473"></a><a class="code" href="Utils_8h.html#a12">00473</a> <span class="keywordtype">int</span> <a class="code" href="Utils_8c.html#a17">C_i_in_set</a>(<span class="keywordtype">int</span> i, SEXP set) {
00474     <span class="keywordflow">if</span> (LENGTH(set) &gt; 0)
00475         <span class="keywordflow">return</span>(<a class="code" href="Utils_8c.html#a16">i_in_set</a>(i, INTEGER(set), LENGTH(set)));
00476     <span class="keywordflow">else</span> 
00477         <span class="keywordflow">return</span>(0);
00478 }
00479     
<a name="l00480"></a><a class="code" href="Utils_8h.html#a8">00480</a> <span class="keywordtype">int</span> <a class="code" href="Utils_8c.html#a18">nrow</a>(SEXP x) {
00481     <span class="keywordflow">return</span>(INTEGER(getAttrib(x, R_DimSymbol))[0]);
00482 }
00483 
<a name="l00484"></a><a class="code" href="Utils_8h.html#a9">00484</a> <span class="keywordtype">int</span> <a class="code" href="Utils_8c.html#a19">ncol</a>(SEXP x) {
00485     <span class="keywordflow">return</span>(INTEGER(getAttrib(x, R_DimSymbol))[1]);
00486 }
00487 
<a name="l00488"></a><a class="code" href="Utils_8h.html#a10">00488</a> <span class="keywordtype">int</span> <a class="code" href="Utils_8c.html#a20">C_whichmax</a>(<span class="keywordtype">double</span> *pvalue, <span class="keywordtype">double</span> *teststat, <span class="keywordtype">int</span> ninputs) {
00489 
00490     <span class="keywordtype">int</span> ans = -1, j;
00491     <span class="keywordtype">double</span> tmppval = 0.0, tmptstat = 0.0;
00492        
00493     <span class="comment">/* &lt;FIXME&gt; can we switch to the log scale here? &lt;/FIXME&gt; */</span>
00494 
00495     tmppval = 0.0;
00496     tmptstat = 0.0;
00497     <span class="keywordflow">for</span> (j = 0; j &lt; ninputs; j++) {
00498         <span class="keywordflow">if</span> (pvalue[j] &gt; tmppval) {
00499             ans = j;
00500             tmppval = pvalue[j];
00501             tmptstat = teststat[j];
00502         } <span class="keywordflow">else</span> {
00503             <span class="keywordflow">if</span> (pvalue[j] == tmppval &amp;&amp; teststat[j] &gt; tmptstat) {  
00504                 ans = j;
00505                 tmppval = pvalue[j];
00506                 tmptstat = teststat[j];
00507             }
00508         }
00509     }
00510     <span class="keywordflow">return</span>(ans);
00511 }
00512 
<a name="l00513"></a><a class="code" href="Utils_8c.html#a21">00513</a> SEXP <a class="code" href="Utils_8c.html#a21">R_whichmax</a>(SEXP x, SEXP y) {
00514     SEXP ans;
00515     
00516     <span class="keywordflow">if</span> (LENGTH(x) != LENGTH(y)) error(<span class="stringliteral">"different length"</span>);
00517     PROTECT(ans = allocVector(INTSXP, 1));
00518     INTEGER(ans)[0] = <a class="code" href="Utils_8c.html#a20">C_whichmax</a>(REAL(x), REAL(y), LENGTH(x));
00519     UNPROTECT(1);
00520     <span class="keywordflow">return</span>(ans);
00521 }
00522 
<a name="l00523"></a><a class="code" href="Utils_8c.html#a22">00523</a> SEXP <a class="code" href="Utils_8c.html#a22">R_listplus</a>(SEXP a, SEXP b, SEXP which) {
00524 
00525     <span class="keywordtype">int</span> na, nb, i, j, *iwhich;
00526     <span class="keywordtype">double</span> *dae, *dbe;
00527     SEXP ae, be;
00528 
00529     na = LENGTH(a);
00530     nb = LENGTH(b);
00531     <span class="keywordflow">if</span> (na != nb) error(<span class="stringliteral">"a and b are of different length"</span>);
00532     
00533     iwhich = LOGICAL(which);
00534     
00535     <span class="keywordflow">for</span> (i = 0; i &lt; na; i++) {
00536         <span class="keywordflow">if</span> (iwhich[i]) <span class="keywordflow">continue</span>;
00537         
00538         ae = VECTOR_ELT(a, i);
00539         be = VECTOR_ELT(b, i);
00540 
00541         <span class="keywordflow">if</span> (LENGTH(ae) != LENGTH(be)) 
00542             error(<span class="stringliteral">"elements %d are of different length"</span>, i);
00543             
00544         <span class="keywordflow">if</span> (!isReal(ae) || !isReal(be))
00545             error(<span class="stringliteral">"elements %d are not of type double"</span>, i);
00546             
00547         dae = REAL(ae);
00548         dbe = REAL(be);
00549         <span class="keywordflow">for</span> (j = 0; j &lt; LENGTH(ae); j++) 
00550             dae[j] += dbe[j];
00551     }
00552     <span class="keywordflow">return</span>(a);
00553 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Aug 31 12:58:11 2005 for party by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
