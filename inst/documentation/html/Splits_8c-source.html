<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>party: Splits.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>Splits.c</h1><a href="Splits_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00009 <span class="preprocessor">#include "<a class="code" href="party_8h.html">party.h</a>"</span>
00010 
00011 
<a name="l00035"></a><a class="code" href="Splits_8h.html#a0">00035</a> <span class="keywordtype">void</span> <a class="code" href="Splits_8c.html#a0">C_split</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> p,
00036              <span class="keyword">const</span> <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> q,
00037              <span class="keyword">const</span> <span class="keywordtype">double</span> *weights, <span class="keywordtype">int</span> n,
00038              <span class="keyword">const</span> <span class="keywordtype">int</span> *orderx, <span class="keyword">const</span> <span class="keywordtype">double</span> *score_y,
00039              <span class="keyword">const</span> <span class="keywordtype">int</span> ORDERED, SEXP splitctrl, SEXP linexpcov2sample, 
00040              SEXP expcovinf, <span class="keywordtype">double</span> *cutpoint, <span class="keywordtype">double</span> *maxstat, 
00041              <span class="keywordtype">double</span> *statistics) {
00042 
00043     <span class="keywordtype">double</span> *dExp_y, *dCov_y, *dlinstat, *dexpect, *dcovar, 
00044            tol, sweights, minprob, minbucket, w, tx, f1, f2, f1w, f2ww, tmp;
00045     <span class="keywordtype">double</span> minobs, maxobs, xmax;
00046     <span class="keywordtype">int</span> lastj, i, j, k, l;
00047 
00048     <span class="keywordflow">if</span> (p != 1) error(<span class="stringliteral">"C_split: p not equal to one"</span>);
00049     tol = <a class="code" href="Classes_8c.html#a66">get_tol</a>(splitctrl);
00050 
00051     <span class="comment">/* init statistics and determine the maximal value with positive weight </span>
00052 <span class="comment">       since we can't choose this one as cutpoint</span>
00053 <span class="comment">    */</span>
00054     xmax = 0.0;
00055     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
00056         statistics[i] = 0.0;
00057         <span class="keywordflow">if</span> (weights[i] &gt; 0.0 &amp;&amp; x[i] &gt; xmax) xmax = x[i];
00058     }
00059 
00060     <span class="comment">/* we already have expecation and covariance of the response</span>
00061 <span class="comment">     * values and the sum of the weights */</span>
00062     dExp_y = REAL(GET_SLOT(expcovinf, <a class="code" href="Classes_8c.html#a0">PL2_expectationSym</a>));
00063     dCov_y = REAL(GET_SLOT(expcovinf, <a class="code" href="Classes_8c.html#a1">PL2_covarianceSym</a>));
00064     sweights = REAL(GET_SLOT(expcovinf, <a class="code" href="Classes_8c.html#a5">PL2_sumweightsSym</a>))[0];
00065 
00066     <span class="comment">/* if there is something to split */</span>
00067     <span class="keywordflow">if</span> (sweights &gt; 1) {
00068 
00069         <span class="comment">/* we need to ensure that at least minbucket weights </span>
00070 <span class="comment">           are there to split (either left or right) */</span>
00071         minprob = <a class="code" href="Classes_8c.html#a71">get_minprob</a>(splitctrl);
00072         minbucket = <a class="code" href="Classes_8c.html#a72">get_minbucket</a>(splitctrl);
00073         minobs = sweights * minprob + 1.0;
00074 
00075         <span class="keywordflow">if</span> (minobs &lt; minbucket) 
00076             minobs = minbucket; 
00077         maxobs = sweights * (1 - minprob) - 1.0;
00078         <span class="keywordflow">if</span> (maxobs &gt; sweights - minbucket) 
00079             maxobs = sweights - minbucket; 
00080 
00081         f1 = (double) sweights / (sweights - 1);
00082         f2 = 1.0 / (sweights - 1);
00083         w = 0.0;
00084     
00085         <span class="comment">/* pointers to the R-objects */</span>
00086         dlinstat = REAL(GET_SLOT(linexpcov2sample, <a class="code" href="Classes_8c.html#a2">PL2_linearstatisticSym</a>));
00087         <span class="keywordflow">for</span> (k = 0; k &lt; q; k++) dlinstat[k] = 0.0;
00088         dexpect = REAL(GET_SLOT(linexpcov2sample, <a class="code" href="Classes_8c.html#a0">PL2_expectationSym</a>));
00089         dcovar = REAL(GET_SLOT(linexpcov2sample, <a class="code" href="Classes_8c.html#a1">PL2_covarianceSym</a>));
00090 
00091         tx = 0.0;
00092         lastj = 0;
00093 
00094         <span class="comment">/* for all possible cutpoints (defined by the observations x) */</span>
00095         <span class="keywordflow">for</span> (i = 0; i &lt; (n - 1); i++) {
00096     
00097             <span class="comment">/* the ordering of the ith observation */</span>
00098             j = orderx[i] - 1;
00099         
00100             <span class="comment">/* if the corresponding weight is zero */</span>
00101             <span class="keywordflow">if</span> (weights[j] == 0.0) <span class="keywordflow">continue</span>;
00102 
00103             <span class="comment">/* just a check: can be removed later */</span>
00104             <span class="keywordflow">if</span> (w &gt; 0 &amp;&amp; x[j] &lt; tx)
00105                 warning(<span class="stringliteral">"C_split: inconsistent ordering: %f &lt; %f!\n"</span>, 
00106                         x[j], tx);
00107         
00108             <span class="comment">/* handle ties: delete the entry of the last visited observation</span>
00109 <span class="comment">               (take care of zero weights!) */</span>
00110             <span class="keywordflow">if</span> (w &gt; 0 &amp;&amp; x[j] == tx)
00111                 statistics[lastj] = 0.0; 
00112 
00113             <span class="comment">/* store the value and position of the j smallest observation */</span>
00114             tx = x[j];
00115             lastj = j;
00116         
00117             w += weights[j];
00118 
00119             <span class="comment">/* do not consider those splits */</span>
00120             <span class="keywordflow">if</span> (w &gt;= maxobs || x[j] &gt;= xmax) <span class="keywordflow">break</span>;
00121 
00122             <span class="comment">/* compute the linear statistic and expectation and </span>
00123 <span class="comment">             * covariance if needed */</span>
00124             <span class="keywordflow">if</span> (ORDERED) {
00125                 <span class="keywordflow">for</span> (k = 0; k &lt; q; k++)
00126                     dlinstat[0] += score_y[k] * y[n * k + j] * weights[j];
00127 
00128                 <span class="comment">/* do not consider those splits */</span>
00129                 <span class="keywordflow">if</span> (w &gt; minobs) {
00130                     dexpect[0] = 0.0;
00131                     <span class="keywordflow">for</span> (k = 0; k &lt; q; k++) {
00132                         dexpect[0] += score_y[k] * w * dExp_y[k];
00133                     }
00134                     dcovar[0] = 0.0;
00135                     f1w = f1 * w;
00136                     f2ww = f2 * w * w;
00137                     <span class="keywordflow">for</span> (k = 0; k &lt; q; k++) {
00138                         <span class="keywordflow">for</span> (l = 0; l &lt; q; l++) {
00139                             dcovar[0] += score_y[k] * 
00140                             (f1w * dCov_y[k*q + l] - f2ww * dCov_y[k*q + l]) * 
00141                             score_y[l];
00142                         }
00143                     }
00144                 } <span class="keywordflow">else</span> {
00145                     <span class="keywordflow">continue</span>;
00146                 }
00147             } <span class="keywordflow">else</span> {
00148                 <span class="keywordflow">for</span> (k = 0; k &lt; q; k++)
00149                     dlinstat[k] += y[n * k + j] * weights[j];
00150  
00151                 <span class="keywordflow">if</span> (w &gt; minobs) {
00152                     <span class="keywordflow">for</span> (k = 0; k &lt; q; k++)
00153                         dexpect[k] = w * dExp_y[k];
00154 
00155                     f1w = f1 * w;
00156                     f2ww = f2 * w * w;
00157                     <span class="keywordflow">for</span> (k = 0; k &lt; q*q; k++)
00158                         dcovar[k] = f1w * dCov_y[k] - f2ww * dCov_y[k];
00159                 } <span class="keywordflow">else</span> {
00160                     <span class="keywordflow">continue</span>;
00161                 }
00162             }
00163         
00164             <span class="comment">/* the absolute standardized test statistic, to be maximized */</span>
00165             <span class="comment">/* statistics[j] = C_maxabsTestStatistic(dlinstat, </span>
00166 <span class="comment">                   dexpect, dcovar, q, tol); */</span>
00167 
00168             <span class="comment">/* much faster but uses maxabs always*/</span>
00169             statistics[j] = 0.0;
00170             <span class="keywordflow">for</span> (k = 0; k &lt; q; k++) {
00171                 <span class="keywordflow">if</span> (dcovar[k * q + k] &lt;= tol) <span class="keywordflow">continue</span>;
00172                 tmp = fabs(dlinstat[k] - dexpect[k]) / sqrt(dcovar[k * q + k]);
00173                 <span class="keywordflow">if</span> (statistics[j] &lt; tmp) statistics[j] = tmp;
00174             }
00175 
00176         }
00177     
00178         <span class="comment">/* search for the maximum and the best separating cutpoint */</span>
00179         maxstat[0] = 0.0;        
00180         <span class="keywordflow">for</span> (i = 0; i &lt; (n - 1); i++) {
00181             <span class="keywordflow">if</span> (statistics[i] &gt; maxstat[0]) {
00182                 maxstat[0] = statistics[i];
00183                 cutpoint[0] = x[i];
00184             }
00185         }
00186     }
00187 }
00188 
00189 
<a name="l00202"></a><a class="code" href="Splits_8c.html#a1">00202</a> SEXP <a class="code" href="Splits_8c.html#a1">R_split</a>(SEXP x, SEXP y, SEXP weights, SEXP orderx, SEXP linexpcov2sample, 
00203              SEXP expcovinf, SEXP splitctrl) {
00204              
00205     SEXP ans, cutpoint, maxstat, statistics;
00206     
00207     PROTECT(ans = allocVector(VECSXP, 3));
00208     SET_VECTOR_ELT(ans, 0, cutpoint = allocVector(REALSXP, 1));
00209     SET_VECTOR_ELT(ans, 1, maxstat = allocVector(REALSXP, 1));
00210     SET_VECTOR_ELT(ans, 2, statistics = allocVector(REALSXP, <a class="code" href="Utils_8c.html#a18">nrow</a>(x)));
00211     
00212     <a class="code" href="Splits_8c.html#a0">C_split</a>(REAL(x), <a class="code" href="Utils_8c.html#a19">ncol</a>(x), REAL(y), <a class="code" href="Utils_8c.html#a19">ncol</a>(y), REAL(weights), <a class="code" href="Utils_8c.html#a18">nrow</a>(x),
00213             INTEGER(orderx), NULL, 0, splitctrl, linexpcov2sample, expcovinf,
00214             REAL(cutpoint), REAL(maxstat), REAL(statistics));
00215     UNPROTECT(1);
00216     <span class="keywordflow">return</span>(ans);
00217 }
00218 
00219 
<a name="l00246"></a><a class="code" href="Splits_8h.html#a1">00246</a> <span class="keywordtype">void</span> <a class="code" href="Splits_8c.html#a2">C_splitcategorical</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *codingx, <span class="keywordtype">int</span> p,
00247                         <span class="keyword">const</span> <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> q,
00248                         <span class="keyword">const</span> <span class="keywordtype">double</span> *weights, <span class="keywordtype">int</span> n,
00249                         <span class="keyword">const</span> <span class="keywordtype">double</span> *score_y, <span class="keyword">const</span> <span class="keywordtype">int</span> ORDERED, 
00250                         <span class="keywordtype">double</span> *standstat,
00251                         SEXP splitctrl, SEXP linexpcov2sample, 
00252                         SEXP expcovinf, <span class="keywordtype">double</span> *cutpoint, <span class="keywordtype">int</span> *levelset, 
00253                         <span class="keywordtype">double</span> *maxstat, <span class="keywordtype">double</span> *statistics) {
00254 
00255     <span class="keywordtype">double</span> tol, *tmpx, *tmptmpx, tmp = 0.0;
00256     <span class="keywordtype">int</span> *irank, *ordertmpx, i, j, k, l, jp, chk;
00257 
00258     tol = <a class="code" href="Classes_8c.html#a66">get_tol</a>(splitctrl);          
00259                      
00260     <span class="comment">/* allocate memory */</span>
00261     tmpx = Calloc(n, <span class="keywordtype">double</span>);
00262     ordertmpx = Calloc(n, <span class="keywordtype">int</span>);
00263     irank = Calloc(p, <span class="keywordtype">int</span>);
00264     tmptmpx = Calloc(n, <span class="keywordtype">double</span>);
00265 
00266     <span class="keywordflow">if</span> (ORDERED) q = 1;
00267     
00268     <span class="comment">/* for all response variables (aka: dummy variables) */</span>
00269     <span class="keywordflow">for</span> (j = 0; j &lt; q; j++) {
00270     
00271         jp = j * p;
00272 
00273         <span class="comment">/* determine the ranking of the kth level among </span>
00274 <span class="comment">           the standardized statistic: This induced an ordering of the </span>
00275 <span class="comment">           observations */</span>
00276         <span class="keywordflow">for</span> (k = 0; k &lt; p; k++) {
00277             irank[k] = 1;
00278             <span class="keywordflow">for</span> (l = 0; l &lt; p; l++)
00279                 <span class="keywordflow">if</span> (standstat[jp + l] &lt; standstat[jp + k]) irank[k]++;
00280         }
00281         
00282         <span class="comment">/* a temporary response variable: the rank of the level */</span>
00283         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
00284             tmpx[i] = (double) irank[codingx[i] - 1];
00285             tmptmpx[i] = tmpx[i];
00286             ordertmpx[i] = i + 1;
00287         }
00288         
00289         <span class="comment">/* order(dtmpx) */</span>
00290         rsort_with_index(tmptmpx, ordertmpx, n);
00291 
00292         <span class="comment">/* search for a cutpoint (now we do have an ordering) */</span>
00293         <a class="code" href="Splits_8c.html#a0">C_split</a>(tmpx, 1, y, q, weights, n, ordertmpx, score_y,
00294                 ORDERED, splitctrl, linexpcov2sample,
00295                 expcovinf, cutpoint, maxstat, statistics);
00296 
00297         <span class="comment">/* if we have seen an improvement: save this segmentation </span>
00298 <span class="comment">           note: there may be splits with equal goodness */</span>
00299         chk = 0;
00300         <span class="keywordflow">if</span> (maxstat[0] &gt; tmp) {
00301             <span class="keywordflow">for</span> (k = 0; k &lt; p; k++) {
00302                 <span class="keywordflow">if</span> (irank[k] &gt; cutpoint[0]) {
00303                     levelset[k] = 1;
00304                     chk += 1;
00305                 } <span class="keywordflow">else</span> {
00306                     levelset[k] = 0;
00307                 }
00308             }
00309             tmp = maxstat[0];
00310         }
00311         <span class="comment">/* &lt;FIXME&gt; make sure that at least one level goes left,</span>
00312 <span class="comment">                   C_split may end up with cutpoint &gt; max(irank), why?</span>
00313 <span class="comment">           &lt;/FIXME&gt;</span>
00314 <span class="comment">        */</span>
00315         <span class="keywordflow">if</span> (chk == 0) tmp = 0.0;
00316     }
00317     maxstat[0] = tmp;
00318 
00319     <span class="comment">/* free memory */</span>
00320     Free(tmpx); Free(ordertmpx); Free(irank); Free(tmptmpx);
00321 }
00322 
00323 
<a name="l00337"></a><a class="code" href="Splits_8c.html#a3">00337</a> SEXP <a class="code" href="Splits_8c.html#a3">R_splitcategorical</a>(SEXP x, SEXP codingx, SEXP y, SEXP weights, 
00338                         SEXP linexpcov2sample, SEXP linexpcov, 
00339                         SEXP expcovinf, SEXP splitctrl) {
00340              
00341     SEXP ans, cutpoint, maxstat, statistics, levelset;
00342     <span class="keywordtype">double</span> *standstat;
00343 
00344     <a class="code" href="Convenience_8c.html#a0">C_LinStatExpCov</a>(REAL(x), <a class="code" href="Utils_8c.html#a19">ncol</a>(x), REAL(y), <a class="code" href="Utils_8c.html#a19">ncol</a>(y), REAL(weights), <a class="code" href="Utils_8c.html#a18">nrow</a>(x),
00345                     1, GET_SLOT(linexpcov, <a class="code" href="Classes_8c.html#a3">PL2_expcovinfSym</a>), linexpcov);
00346 
00347     standstat = Calloc(<a class="code" href="Classes_8c.html#a63">get_dimension</a>(linexpcov), <span class="keywordtype">double</span>);
00348     <a class="code" href="TestStatistic_8c.html#a0">C_standardize</a>(REAL(GET_SLOT(linexpcov, <a class="code" href="Classes_8c.html#a2">PL2_linearstatisticSym</a>)),
00349                   REAL(GET_SLOT(linexpcov, <a class="code" href="Classes_8c.html#a0">PL2_expectationSym</a>)),
00350                   REAL(GET_SLOT(linexpcov, <a class="code" href="Classes_8c.html#a1">PL2_covarianceSym</a>)),
00351                   <a class="code" href="Classes_8c.html#a63">get_dimension</a>(linexpcov), <a class="code" href="Classes_8c.html#a66">get_tol</a>(splitctrl), standstat);
00352 
00353     PROTECT(ans = allocVector(VECSXP, 4));
00354     SET_VECTOR_ELT(ans, 0, cutpoint = allocVector(REALSXP, 1));
00355     SET_VECTOR_ELT(ans, 1, maxstat = allocVector(REALSXP, 1));
00356     SET_VECTOR_ELT(ans, 2, statistics = allocVector(REALSXP, <a class="code" href="Utils_8c.html#a18">nrow</a>(x)));
00357     SET_VECTOR_ELT(ans, 3, levelset = allocVector(INTSXP, <a class="code" href="Utils_8c.html#a19">ncol</a>(x)));
00358     
00359     <a class="code" href="Splits_8c.html#a2">C_splitcategorical</a>(INTEGER(codingx), <a class="code" href="Utils_8c.html#a19">ncol</a>(x), REAL(y), <a class="code" href="Utils_8c.html#a19">ncol</a>(y), REAL(weights), 
00360                        <a class="code" href="Utils_8c.html#a18">nrow</a>(x), NULL, 0, standstat, 
00361                        splitctrl, linexpcov2sample, expcovinf, 
00362                        REAL(cutpoint), INTEGER(levelset), REAL(maxstat), 
00363                        REAL(statistics));
00364 
00365     UNPROTECT(1);
00366     Free(standstat);
00367     <span class="keywordflow">return</span>(ans);
00368 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 6 01:02:54 2005 for party by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
